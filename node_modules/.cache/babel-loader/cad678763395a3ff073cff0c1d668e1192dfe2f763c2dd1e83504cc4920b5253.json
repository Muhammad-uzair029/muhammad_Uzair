{"ast":null,"code":"import { Children, isValidElement } from 'react';\nimport Backspace from '../components/Backspace';\nimport getTypedChildren from './getTypedChildren';\nimport Paste from '../components/Paste';\nimport isNil from './isNil';\nimport Delay from '../components/Delay';\nexport default function getTypedChildrenArray(children, splitter) {\n  const typedLinesArray = [];\n  const currentTypedLines = [];\n  let isPaste = false;\n  const recurse = node => {\n    Children.forEach(node, child => {\n      if (isValidElement(child)) {\n        if (child.type === Delay) return;\n        if (child.type === Backspace) {\n          let count = child.props.count;\n          while (count--) {\n            let lineIndex = currentTypedLines.length - 1;\n            let line = currentTypedLines[lineIndex];\n            while (line === null && lineIndex > 0) {\n              lineIndex -= 1;\n              line = currentTypedLines[lineIndex];\n            }\n            if (line === null) break;\n            if (typeof line === 'object') currentTypedLines[lineIndex] = null;\n            if (typeof line === 'string') {\n              const tokens = splitter(line);\n              const newLine = tokens.slice(0, -1).join('');\n              currentTypedLines[lineIndex] = newLine || null;\n            }\n            typedLinesArray.push([...currentTypedLines]);\n          }\n          return;\n        }\n        if (child.type === Paste) {\n          isPaste = true;\n          Children.forEach(child.props.children, recurse);\n          isPaste = false;\n          return;\n        }\n        if (isNil(child.props.children)) {\n          currentTypedLines.push(child);\n          typedLinesArray.push([...currentTypedLines]);\n          return;\n        }\n        Children.forEach(child.props.children, recurse);\n      }\n      const str = (() => {\n        if (typeof child === 'number') return child.toString(10);\n        if (typeof child === 'string') return child;\n      })();\n      if (str === undefined) return;\n      if (isPaste) {\n        currentTypedLines.push(str);\n        typedLinesArray.push([...currentTypedLines]);\n        return;\n      }\n      const tokens = splitter(str);\n      const lastIndex = currentTypedLines.length;\n      for (let tokenIndex = 1; tokenIndex <= tokens.length; tokenIndex++) {\n        const newLine = tokens.slice(0, tokenIndex).join('');\n        currentTypedLines[lastIndex] = newLine;\n        typedLinesArray.push([...currentTypedLines]);\n      }\n    });\n  };\n  recurse(children);\n  return typedLinesArray.map(typedLines => getTypedChildren(children, typedLines));\n}","map":{"version":3,"names":["Children","isValidElement","Backspace","getTypedChildren","Paste","isNil","Delay","getTypedChildrenArray","children","splitter","typedLinesArray","currentTypedLines","isPaste","recurse","node","forEach","child","type","count","props","lineIndex","length","line","tokens","newLine","slice","join","push","str","toString","undefined","lastIndex","tokenIndex","map","typedLines"],"sources":["/Users/softaims/Desktop/muhammad_Uzair/muhammad_Uzair/node_modules/react-typist-component/dist/utils/getTypedChildrenArray.js"],"sourcesContent":["import { Children, isValidElement } from 'react';\nimport Backspace from '../components/Backspace';\nimport getTypedChildren from './getTypedChildren';\nimport Paste from '../components/Paste';\nimport isNil from './isNil';\nimport Delay from '../components/Delay';\nexport default function getTypedChildrenArray(children, splitter) {\n    const typedLinesArray = [];\n    const currentTypedLines = [];\n    let isPaste = false;\n    const recurse = (node) => {\n        Children.forEach(node, child => {\n            if (isValidElement(child)) {\n                if (child.type === Delay)\n                    return;\n                if (child.type === Backspace) {\n                    let count = child.props.count;\n                    while (count--) {\n                        let lineIndex = currentTypedLines.length - 1;\n                        let line = currentTypedLines[lineIndex];\n                        while (line === null && lineIndex > 0) {\n                            lineIndex -= 1;\n                            line = currentTypedLines[lineIndex];\n                        }\n                        if (line === null)\n                            break;\n                        if (typeof line === 'object')\n                            currentTypedLines[lineIndex] = null;\n                        if (typeof line === 'string') {\n                            const tokens = splitter(line);\n                            const newLine = tokens.slice(0, -1).join('');\n                            currentTypedLines[lineIndex] = newLine || null;\n                        }\n                        typedLinesArray.push([...currentTypedLines]);\n                    }\n                    return;\n                }\n                if (child.type === Paste) {\n                    isPaste = true;\n                    Children.forEach(child.props.children, recurse);\n                    isPaste = false;\n                    return;\n                }\n                if (isNil(child.props.children)) {\n                    currentTypedLines.push(child);\n                    typedLinesArray.push([...currentTypedLines]);\n                    return;\n                }\n                Children.forEach(child.props.children, recurse);\n            }\n            const str = (() => {\n                if (typeof child === 'number')\n                    return child.toString(10);\n                if (typeof child === 'string')\n                    return child;\n            })();\n            if (str === undefined)\n                return;\n            if (isPaste) {\n                currentTypedLines.push(str);\n                typedLinesArray.push([...currentTypedLines]);\n                return;\n            }\n            const tokens = splitter(str);\n            const lastIndex = currentTypedLines.length;\n            for (let tokenIndex = 1; tokenIndex <= tokens.length; tokenIndex++) {\n                const newLine = tokens.slice(0, tokenIndex).join('');\n                currentTypedLines[lastIndex] = newLine;\n                typedLinesArray.push([...currentTypedLines]);\n            }\n        });\n    };\n    recurse(children);\n    return typedLinesArray.map(typedLines => getTypedChildren(children, typedLines));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}